use std::future::Future;
use std::pin::Pin;
use std::task::{Context, Poll};
use async_std::task::{self, sleep, spawn};
use std::time::Duration;

// The `Future` type generated by our `async { ... }` block
struct AsyncFuture {
    fut_one: FutOne,
    fut_two: FutTwo,
    state: State,
}

// List of states our `async` block can be in
#[derive(Debug)]
enum State {
    AwaitingFutOne,
    AwaitingFutTwo,
    Done,
}

impl Future for AsyncFuture {
    type Output = ();

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {
        loop {
            match self.state {
                State::AwaitingFutOne => {
                     println!("AwaitingFutOne {:?}", State::AwaitingFutOne);
                }
                State::AwaitingFutTwo => {
                    println!("AwaitingFutTwo {:?}", State::AwaitingFutTwo);
                }
                State::Done => return Poll::Ready(()),
            }
        }
    }
}


async fn sleeps() {
    for i in 1..=10 {
        println!("Sleeps {}", i);
        sleep(Duration::from_millis(500));
    }
}

async fn interrupts() {
    for i in 1..=10 {
        println!("Interrupts {}", i);
        sleep(Duration::from_millis(1000));
    }
}

#[async_std::main]
async fn main() {
    let sleeps = spawn(sleeps());
    interrupts().await;

    sleeps.await;
}